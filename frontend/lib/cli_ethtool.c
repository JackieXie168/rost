/*
 *  CVS Version: $Id: cli_ethtool.c,v 1.3 2013/08/09 13:27:46 olof Exp $
 *
 *  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren
 *
 *  This file is part of ROST.
 *
 *  ROST is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  ROST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along wth ROST; see the file COPYING.  If not, see
 *  <http://www.gnu.org/licenses/>.
 *
 */
#ifdef HAVE_ROST_CONFIG_H
#include "rost_config.h" /* generated by config & autoconf */
#endif /* HAVE_ROST_CONFIG_H */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <assert.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <netinet/in.h>

#include <linux/ethtool.h>
#include <linux/sockios.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clicon/clicon.h>
#include <clicon/clicon_cli.h>

#include "ethtool.h"

struct ethtool_cmd *
ethtool_client_gset(clicon_handle h, char *ifname, const char *label)
{
    uint16_t            eclen;
    struct ethtool_cmd *tmp, *ec = NULL;
    struct clicon_msg  *msg;
    char                *s;

    if (clicon_rpc_call(h, 0, "ethtool", "ethtool_gset", 
			strlen(ifname), ifname, 
			(char **)&tmp, &eclen,
			label) < 0)
	goto done;
#if 0
    msg = clicon_msg_call_encode(0, "ethtool", "ethtool_gset", 
			      strlen(ifname), ifname, __FUNCTION__);
    if (msg == NULL)
	goto done;
    if ((s = clicon_sock(h)) == NULL)
	goto done;
    if (clicon_rpc_connect(msg, s, (char **)&tmp, &eclen, label) < 0)
	goto done;
#endif
    ec = tmp;
    ec->cmd = ntohl(tmp->cmd);
    ec->supported = ntohl(tmp->supported);
    ec->advertising = ntohl(tmp->advertising);
    ec->speed = ntohs(tmp->speed);
    ec->maxtxpkt = ntohl(tmp->maxtxpkt);
    ec->maxrxpkt = ntohl(tmp->maxrxpkt);
    ec->speed_hi = ntohs(tmp->speed_hi);
    ec->eth_tp_mdix = ntohs(tmp->eth_tp_mdix);
   
done:
    unchunk_group(__FUNCTION__);
    return ec;
}


int
ethtool_client_getlink(clicon_handle h, char *ifname, uint8_t *link)
{
    int               retval = -1;
    char             *ret;
    uint16_t          len;
    struct clicon_msg *msg;
    char              *s;

#if CLICON_3_1
    if (clicon_rpc_call(h, 0, "ethtool", "ethtool_getlink", 
			strlen(ifname), ifname, 
			(char **)&ret, &len,
			__FUNCTION__) < 0)
	goto done;
#else
    msg = clicon_msg_call_encode(0, "ethtool", "ethtool_getlink", 
				strlen(ifname), ifname, __FUNCTION__);
    if (msg == NULL)
	goto done;
    if ((s = clicon_sock(h)) == NULL)
	goto done;
    if (clicon_rpc_connect(msg, s, (char **)&ret, &len, __FUNCTION__) < 0)
	goto done;
#endif
    *link = (uint8_t)*ret;
    retval = 0;
done:
    unchunk_group(__FUNCTION__);
    return retval;
}


struct rost_etstats *
ethtool_client_gstats(clicon_handle h, char *ifname, const char *label)
{
    uint16_t            etslen;
    struct clicon_msg  *msg;
    struct rost_etstats *tmp, *ets = NULL;
    char                *s;
    int                 i;
    
#if CLICON_3_1
    if (clicon_rpc_call(h, 0, "ethtool", "ethtool_gstats", 
			strlen(ifname), ifname, 
			(char **)&tmp, &etslen,
			label) < 0)
	goto done;
#else
    msg = clicon_msg_call_encode(0, "ethtool", "ethtool_gstats", 
				strlen(ifname), ifname, __FUNCTION__);
    if (msg == NULL)
	goto done;
    
    if ((s = clicon_sock(h)) == NULL)
	goto done;
    if (clicon_rpc_connect(msg, s, (char **)&tmp, &etslen, label) < 0)
	goto done;
#endif
    ets = tmp;
    for (i = 0; i < ets->ets_nstats; i++)
	ets->ets_stat[i].etse_value = htonll(tmp->ets_stat[i].etse_value);

done:
    unchunk_group(__FUNCTION__);
    return ets;
}
