/*
 *  CVS Version: $Id: cli_system.c,v 1.10 2013/08/05 14:30:56 olof Exp $
 *
 *  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren
 *
 *  This file is part of ROST.
 *
 *  ROST is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  ROST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along wth ROST; see the file COPYING.  If not, see
 *  <http://www.gnu.org/licenses/>.
 *
 */
#ifdef HAVE_ROST_CONFIG_H
#include "rost_config.h" /* generated by config & autoconf */
#endif /* HAVE_ROST_CONFIG_H */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/vfs.h>
#include <sys/types.h>
#include <sys/param.h>
#include <dirent.h>
#include <unistd.h>
#include <time.h>
#include <ctype.h>
#include <net/if.h>
#include <netinet/in.h>
#include <pwd.h>

#ifdef HAVE_LINUX_ETHTOOL_H
#include <linux/ethtool.h>
#endif /* HAVE_LINUX_ETHTOOL_H */

/* clicon */
#include <cligen/cligen.h>
#include <clicon/clicon.h>
#include <clicon/clicon_cli.h>

/* lib */
#include "system.h"
#include "ethtool.h"
#include "cli_procfs.h"

#include "cli_system.h"

/*
 * uptime_t2str
 * transform seconds to uptime formatted string
 */
static int
uptime_t2str(int u, char *s, int len)
{
    int days, hours, minutes;

    days = u / (60*60*24);
    minutes = u / 60;
    hours = (minutes / 60) % 24;
    minutes %= 60;
    if (hours)
	snprintf(s, len, "%d day%s, %2d:%02d",
		 days, (days != 1) ? "s" : "",
		 hours,
		 minutes);
    else
	snprintf(s, len, "%d day%s, %02d min",
		 days, (days != 1) ? "s" : "",
		 minutes);
    return 0;
}

int
cli_version(clicon_handle h, cvec *vars, cg_var *arg)
{
    char serialstr[128];
    char product[128];
    char upstr[128];
    int sec;

    if (rost_get_serialno(serialstr, sizeof(serialstr)) < 0)
	return -1;
    if (rost_get_product(product, sizeof(product)) < 0)
	return -1;
    if (rost_uptime(&sec) < 0)
	return -1;
    if (uptime_t2str(sec, upstr, sizeof(upstr)) < 0)
	return -1;
    cli_output(stdout, "Product: %s\n", product);
    cli_output(stdout, "Software version: %s\n", CLICON_VERSION);
    cli_output(stdout, "Serial number: %s\n", serialstr);
    cli_output(stdout, "Uptime: %s\n", upstr);
    cli_output(stdout, "Compiled: %s\n", CLICON_BUILDSTR);
    cli_output(stdout, "%s\n", COPYRIGHTSTATEMENT);
    cli_output(stdout, "%s\n", LICENSE);

    unchunk_group(__FUNCTION__);
    return 1;
}

int 
cli_show_archive(clicon_handle h, cvec *vars, cg_var *arg)
{
    DIR	*dirp;
    struct statfs sfs;
    struct dirent *dp;
    struct stat st;
    int retval = -1;
    char filename[MAXPATHLEN];
    struct tm *tm;
    char *archivedir;

    archivedir = clicon_archive_dir(h);
    if ((dirp = opendir(archivedir)) == 0){
	fprintf(stderr, "show_archive: opendir(%s) %s\n", 
		archivedir, strerror(errno));
	return -1;
    }
    if (statfs(archivedir, &sfs) < 0){
	fprintf(stderr, "show_archive: statfs: %s\n", strerror(errno));
	goto quit;
    }
    printf("%-7s %-12s %-8s \n", "Size[b]", "Date", "Name");
    while ((dp = readdir(dirp)) != NULL)
	if (strcmp(dp->d_name, ".") != 0 &&
	    strcmp(dp->d_name, "..") != 0){
	    snprintf(filename, MAXPATHLEN, "%s/%s",
		     archivedir,
		     dp->d_name);
	    if (lstat(filename, &st) < 0){
		fprintf(stderr, "show_archive: stat(%s): %s\n",
			dp->d_name, strerror(errno));
		goto quit;
	    }
	    tm = localtime(&st.st_mtim.tv_sec);
	    printf("%7d %s %2d %02d:%02d %-8s \n", 
		   (int)st.st_size,
		   mon2name(tm->tm_mon), 
		   tm->tm_mday,
		   tm->tm_hour, tm->tm_min,
		   dp->d_name);
	}
    retval = 0;
  quit:
    closedir(dirp);
    return retval;
}

int
cli_show_inventory(clicon_handle h, cvec *vars, cg_var *arg)
{
    int i;
    int ncpu;
    char *value;
    struct clicon_procfs_cpu *cpus;
    struct clicon_procfs_ifstats *sp;
#ifdef HAVE_LINUX_ETHTOOL_H
    char *cmd;
    FILE *f;
    char buf[512];
    struct ethtool_drvinfo info;
#endif /* HAVE_LINUX_ETHTOOL_H */
    int n;

    /* CPU */
    if ((cpus = clicon_procfs_cpuinfo(&ncpu,  __FUNCTION__)) == NULL) {
	cli_output(stderr, "Failed to retrieve CPU information\n");
    } else {
	for (i = 0; i < ncpu; cpus++, i++)  {
	    value = clicon_procfs_cpuinfo_value(cpus, "processor");
	    cli_output(stdout, "CPU%-5s: ", value ? value : "-1"); 
	    value = clicon_procfs_cpuinfo_value(cpus, "model name");
	    cli_output(stdout, "%s\n", value ? value : "unknown");
	}
    }

    /* DEVS */
    if((sp = clicon_procfs_ifstats(&n, __FUNCTION__)) != NULL){
	for ( ; n > 0; n--, sp++)  {
#ifdef HAVE_LINUX_ETHTOOL_H
	    if (rost_ethtool_drvinfo(sp->pi_ifname, &info) == 0 &&
		info.bus_info && strlen(info.bus_info)) {
		cmd = chunk_sprintf(__FUNCTION__,
				    "%s -s %s", PROG_LSPCI, info.bus_info);
		if (cmd && (f=popen(cmd, "r")) && fgets(buf, sizeof(buf)-1,f)){
		    cli_output(stdout, "%-8s: %s\n", 
			       sp->pi_ifname,
			       clicon_strtrim(strchr(strchr(buf, ':')+1, ':')+1, __FUNCTION__));
		    fclose(f);
		}
	    }
#endif /* HAVE_LINUX_ETHTOOL_H */
	}
    }
    unchunk_group(__FUNCTION__);
    return 0;
}


/*
 * Shutdown/halt system
 */
int
cli_reload(clicon_handle h, cvec *vars, cg_var *arg)
{
  int ret;
  char *ptr;
  char *cmd;
  struct tm tm;
  extern char *strptime(const char *s, const char *format, struct tm *tm);
  cg_var *cv0 = cvec_i(vars, 0);


  /* Check format of "at" argument.
   * XXX Shuld be done better. Perhaps cligen support for date/time
   */
  if ((ptr = strstr(cv_string_get(cv0), " at ")) != NULL) {
    ptr += strlen(" at ");
    if (strptime(ptr, "%R", &tm) == NULL) {
      clicon_err(OE_UNDEF, 0, "reload: Invalid time format");
      return 0;
    }
  }

  if (cli_yesno("Proceed with reload? [y/N] ") == 0) {
    cli_output(stdout, "Aborted\n");
    return 0;
  }

  /* Remove current scheduled reload if any */
  clicon_proc_run("/usr/bin/sudo /sbin/shutdown -c", NULL, 1);

  cmd = cgv_fmt_string (vars, cv_string_get(arg));
  if (cmd == NULL)
    return 0;
  
  if ((ret = clicon_proc_daemon(cmd)) != 0)
    clicon_err(OE_UNDEF, ret, "reload: '%s' returned %d", cmd, ret);
  
  free(cmd);
  return 0;
}

/*
 * Shutdown/halt system
 */
int
cli_reload_cancel(clicon_handle h, cvec *vars, cg_var *arg)
{
  int ret;
  char *cmd;

  cmd = cgv_fmt_string (vars, cv_string_get(arg));
  if (cmd == NULL)
    return 0;

  ret = clicon_proc_run(cmd, NULL, 1);
  free (cmd);

  if (ret == 0)
    cli_output(stdout, "Reload cancelled\n");
  else
    cli_output(stdout, "%No reload is scheduled.\n");
  return 0;
}


/*
 * Ask user a yes/no question and read response.
 * Returns: -1 on failure, 0 on no, 1 on yes.
 */
int
cli_yesno(char *fmt, ...)
{
  int len;
  char *s;
  va_list ap;
  char ans[128];

  va_start(ap, fmt);
  len = vsnprintf(NULL, 0, fmt, ap);
  va_end(ap);

  if (len <= 0 || (s = malloc(len+1)) == NULL)
    return -1;

  va_start(ap, fmt);
  vsnprintf(s, len+1, fmt, ap);
  va_end(ap);

  cli_output(stdout, s);
  free(s);

  memset(ans, '\0', sizeof(ans));
  if (fgets(ans, sizeof(ans)-1, stdin) == NULL)
    return -1;
  
  /* Strip off newline */
  ans[strcspn(ans, "\r\n")] = '\0';
  if (strcasecmp(ans, "Y") && strcasecmp(ans, "YES"))
    return 0;

  return 1;
}

