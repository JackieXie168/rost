/*
 *  CVS Version: $Id: cli_interface.c,v 1.8 2013/08/05 14:30:56 olof Exp $
 *
 *  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren
 *
 *  This file is part of ROST.
 *
 *  ROST is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  ROST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along wth ROST; see the file COPYING.  If not, see
 *  <http://www.gnu.org/licenses/>.
 *
 */
#ifdef HAVE_OSR_CONFIG_H
#include "osr_config.h" /* generated by config & autoconf */
#endif /* HAVE_OSR_CONFIG_H */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <inttypes.h>
#include <ifaddrs.h>
#include <net/if.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clicon/clicon.h>
#include <clicon/clicon_cli.h>

#ifdef HAVE_LINUX_ETHTOOL_H
#include <linux/ethtool.h>
#include "ethtool.h"
#include "cli_ethtool.h"
#endif /* HAVE_LINUX_ETHTOOL_H */

/* lib */
#include "cli_procfs.h"
#include "interface.h"

#include "cli_quaggapi.h"
#include "cli_interface.h"


static int
cli_show_interface(clicon_handle h, cvec *vars, char *ifname)
{
    char *cmd;
    struct clicon_procfs_ifstats *stats;
#ifdef HAVE_LINUX_ETHTOOL_H
    uint8_t linkstatus;
    struct ethtool_cmd *ep;
    uint32_t speed;
#endif /* HAVE_LINUX_ETHTOOL_H */
    cg_var *cv;
    
    cmd = chunk_sprintf(__FUNCTION__, "show interface %s", ifname);
    if ((cv = cv_new(CGV_STRING)) == NULL){
	cli_output(stderr, "%s: %s\n", __FUNCTION__, strerror(errno));
	goto done;
    }
    if (cv_parse(cmd, cv) == 0) {
	cli_zebra_exec(h, vars, cv);
	cv_reset(cv);
    }
    unchunk(cmd);
        
#ifdef HAVE_LINUX_ETHTOOL_H
    if (isether(ifname)){
	/* Get speed/duplex settings */
	if ((ep = ethtool_client_gset(h, ifname, __FUNCTION__)) == NULL)
	    goto done;
    
	/* Get link status */
	if ((linkstatus = ethtool_client_getlink(h, ifname, &linkstatus)) < 0)
	    goto done;
    
	/* Get interface speed */
	speed = ethtool_cmd_speed(ep);

	cli_output(stdout, "  Auto-negotiation %s",
		   (ep->autoneg == AUTONEG_DISABLE) ? "off" : "on");
	if (linkstatus) {
	    switch (ep->duplex) {
	    case DUPLEX_HALF:
		cli_output(stdout, ", Half-duplex");
		break;
	    case DUPLEX_FULL:
		cli_output(stdout, ", Full-duplex");
		break;
	    }
	    if (speed && speed != (uint16_t)(-1) && speed != (uint32_t)(-1))
		cli_output(stdout, ", %uMb/s", speed);
	    cli_output(stdout, "\n");
	} 
	else {
	    cli_output(stdout, ", no link\n");
	}
    }
#endif /* HAVE_LINUX_ETHTOOL_H */
    
    if ((stats = clicon_procfs_ifstat(ifname, __FUNCTION__)) != NULL) {
	/* RX */
	cli_output(stdout, "  RX:  "
		   "%" PRIu64 " packets, "
		   "%" PRIu64 " bytes, "
		   "%" PRIu64 " multicast\n"
		   "       "
		   "%" PRIu64 " errors, "
		   "%" PRIu64 " drops, "
		   "%" PRIu64 " overruns, "
		   "%" PRIu64 " frame\n",
		   stats->pi_rxpkt, stats->pi_rxbyte, stats->pi_rxmcast,
		   stats->pi_rxerr, stats->pi_rxdrop, 
		   stats->pi_rxfifo, stats->pi_rxframe);
	
	/* TX */
	cli_output(stdout, "  TX:  "
		   "%"PRIu64" packets, "
		   "%"PRIu64" bytes\n"
		   "       "
		   "%"PRIu64" errors, "
		   "%"PRIu64" drops, "
		   "%"PRIu64" overruns, "
		   "%"PRIu64" carrier\n",
		   stats->pi_txpkt, stats->pi_txbyte,
		   stats->pi_txerr, stats->pi_txdrop, 
		   stats->pi_txfifo, stats->pi_txcarrier);
    }
    
done:
    unchunk_group(__FUNCTION__);
    return 0;
}


/*
 * cli_show_interfaces
 * Use quagga to print interface information. This is made primarily
 * by laziness.
 * Either the i/f in the argument, or all interfaces on the machine 
 * (of type lo/eth
 */
int
cli_show_interfaces(clicon_handle h, cvec *vars, cg_var *arg)
{
    int     i;
    cg_var *cgif;
    cg_var *cv;
    char   *pfx[] = OSR_IFTYPES;
    struct clicon_if *iflist;
    int     j, len;

    if ((cgif = cvec_find(vars, "interface")) != NULL)
	cli_show_interface(h, vars, cv_string_get(cgif));
    else {
	if (cvec_find(vars, "brief") != NULL) {
	    if ((cv = cv_new(CGV_STRING)) == NULL){
		cli_output(stderr, "%s: %s\n", __FUNCTION__, strerror(errno));
		return -1;
	    }
	    if (cv_parse("show interface description", cv) == 0) {
		cli_zebra_exec(h, vars, cv);
	    }
	    cv_free(cv);

	} else{
	    for (j=0; pfx[j]; j++) {
		if (clicon_iflist_get(pfx[j], __FUNCTION__, &iflist, &len) < 0)
		    return -1;
		for (i=0; i<len; i++){
		    cli_show_interface(h, vars, iflist[i].ci_name);
		}
	    }
	}
    }
    return 0;
}


/*
 * Print NIC statistics
 */
int
cli_show_iface_stats(clicon_handle h, cvec *vars, cg_var *arg)
{
#ifdef HAVE_LINUX_ETHTOOL_H
    int i;
    cg_var *cv1 = cvec_i(vars, 1);
    char *ifname;
    struct osr_etstats *etsp;

    ifname = cv_string_get(cv1);
    /* Get interface stats */
    if ((etsp = ethtool_client_gstats(h, ifname, __FUNCTION__)) == NULL)
	goto done;
    
    cli_output(stdout, "%s statistics:\n", ifname);
    for (i = 0; i < etsp->ets_nstats; i++)
	cli_output(stdout, "    %s:%*s%"PRIu64"\n", 
		   etsp->ets_stat[i].etse_name, 
		   25-strlen(etsp->ets_stat[i].etse_name), " ",
		   etsp->ets_stat[i].etse_value);
    done:
    unchunk_group(__FUNCTION__);
#else /* HAVE_LINUX_ETHTOOL_H */
    cli_output("Unsupported on this platform\n");
#endif /* HAVE_LINUX_ETHTOOL_H */
    return 0;
}

