/*
 *  CVS Version: $Id: syslog.c,v 1.29 2013/08/05 14:31:08 olof Exp $
 *
 *  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren
 *
 *  This file is part of ROST.
 *
 *  ROST is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  ROST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along wth ROST; see the file COPYING.  If not, see
 *  <http://www.gnu.org/licenses/>.
 *
 */
#ifdef HAVE_ROST_CONFIG_H
#include "rost_config.h" /* generated by config & autoconf */
#endif /* HAVE_ROST_CONFIG_H */

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <unistd.h>
#include <time.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <sqlite3.h>
#include <sys/inotify.h>
#ifdef HAVE_SYS_INOTIFY_H
#define INOTIFY_EVENT_SIZE  ( sizeof (struct inotify_event) )
#define INOTIFY_EVENT_BUF_LEN     ( 1024 * ( INOTIFY_EVENT_SIZE + 16 ) )
#else
#error No inotify detected. Only implemented for linux inotify. BSD uses kqueue
#endif

/* clicon */
#include <cligen/cligen.h>
#include <clicon/clicon.h>
#include <clicon/clicon_cli.h>

/* rost lib */
#include <rost_syslog.h>

/* local */
#include "ios.h"

struct syslog_mon {
    int		ol_fd;
    uint32_t	ol_wd;
    time_t	ol_timestamp;
    void 	(*ol_outcb)(char *, ...);
};


/*
 * List contents of local SQL syslog database
 */
static int
syslog_show_local_cb(void (outcb)(char *, ...),
			  int argc, 
			  char **argv, 
			  char **colname)
{
#define COLDATE 1
#define COLPROG 5
#define COLPID  6
#define COLMSG  7

  outcb("%s %s[%s]: %s\n", 
	argv[COLDATE],
	argv[COLPROG], 
	argv[COLPID] ? argv[COLPID] : "",
	argv[COLMSG]);
  return 0;
}


/*
 * XXXX A bit IOS'ish. Should be cleaned up to allow formatting from CLI.
 */ 
int
syslog_show_local(clicon_handle h, void (outcb)(char *, ...), int argc, char **argv)
{
  char *str;
  cg_var *trap = NULL;
  cg_var *sql = NULL;
  cvec *vr = NULL;
  int npairs;
  struct db_pair *pairs;

  /* Get trap level */
  trap = dbvar2cv(clicon_running_db(h), "logging.trap", "level");

  /* Get local sql logging status */
  sql = dbvar2cv(clicon_running_db(h), "logging.buffered", "level");

  outcb("Syslog logging:\n\n");
  outcb("  Buffer logging: %s%s\n\n", 
	sql ? "enabled, level " : "disabled",
	sql ? cv_string_get(sql) : "");
  /* Get all keys/values for vector */
  npairs = db_regexp(clicon_running_db(h), "logging\\.host\\.[0-9]+",
		     __FUNCTION__, &pairs, 0);
  if (npairs < 0)
    goto catch;

  if (npairs <= 0)
    outcb("  Trap logging: disabled\n\n");
  else
    outcb("  Trap logging: enabled, level %s, %d destinations\n",
	  trap ? cv_string_get(trap) : "notice",
	  npairs);
  
  /* Loop through list */
  str = clicon_db2txt_buf(h, clicon_running_db(h),
			  "@EACH($logging.host[], $host)\n"
			  "       Logging to ${host->host}, ${host->protocol} port ${host->port}\n"
			  "@END\n");
  if (str) {
    outcb("%s\n", str);
    free(str);
  }

  syslog_sqlite3_exec(SYSLOG_DB,
		      SQLITE_OPEN_READONLY, 
		      "SELECT * FROM logs ORDER BY id DESC",
		      (void *)syslog_show_local_cb,
		      outcb);
 catch:
  if (trap) 
      cv_free(trap);
  if (sql)  
      cv_free(sql);
  if (vr)  
      cvec_free(vr);
  unchunk_group(__FUNCTION__);
  
  return 0;
}

static int
syslog_get_msgs(struct syslog_mon *lm)
{
    int ret = -1;
    char *query;
    char *queryfmt =
	"SELECT * FROM logs WHERE datetime > '%s' ORDER BY id ASC;";
    char timestr[64];
    struct tm *tmp;

    tmp = localtime(&lm->ol_timestamp);
    if (tmp == NULL) {
	clicon_err(OE_SYSLOG, errno, "%s: localtime", __FUNCTION__);
	goto catch;
    }

    if(strftime(timestr, sizeof(timestr)-1, "%Y-%m-%d %H:%M:%S",  tmp) == 0) {
	clicon_err(OE_SYSLOG, errno, "%s: strftime", __FUNCTION__);
	goto catch;
    }

    query = chunk_sprintf(__FUNCTION__, queryfmt, timestr);
    if(query == NULL) {
	clicon_err(OE_SYSLOG, errno, "%s: chunk", __FUNCTION__);
	goto catch;
    }

    if ((ret = syslog_sqlite3_exec(SYSLOG_DB, 
				   SQLITE_OPEN_READONLY,
				   query, 
				   (void *)syslog_show_local_cb,
				   lm->ol_outcb)) == 0)
	time(&lm->ol_timestamp);

catch:
    unchunk_group(__FUNCTION__);
    return ret;
}


/*
 * Callback from cligen gl_select()
 */
static int 
syslog_monitor_cb(int fd, void *arg)
{
    int length, i = 0;
    char buffer[INOTIFY_EVENT_BUF_LEN];
    struct syslog_mon *lm = (struct syslog_mon *)arg;
    
    length = read( fd, buffer, INOTIFY_EVENT_BUF_LEN );
    if ( length < 0 ) {
	perror( "inotify read" );
	return -1;
    }  
    
    /* Read events and check for changes to syslog buffer file */
    while ( i < length ) {
	struct inotify_event *event = ( struct inotify_event * ) &buffer[ i ]; 
	
	if ( event->mask & IN_MODIFY ) {
	    if ( !(event->mask & IN_ISDIR) &&
		 !strcmp(event->name, SYSLOG_DBFILE)
		) {
		syslog_get_msgs(lm);
	    }
	}
	i += INOTIFY_EVENT_SIZE + event->len;
    }
    
    return 0;
}





/*
 * Register inotify instance and register it's file descriptor with cligen.
 */
static int
syslog_set_monitor( struct syslog_mon *lm )
{
    /* Create INOTIFY instance */
    lm->ol_fd = inotify_init();
    if (lm->ol_fd  < 0) {
	perror( "inotify_init" );
	return -1;
    }
    
    /* Register watch descriptor */
    lm->ol_wd = inotify_add_watch(lm->ol_fd,
				  SYSLOG_DBDIR,
				  IN_MODIFY );
    if (lm->ol_wd < 0) {
	perror("inotify_add_watch");
	return -1;
    }

    /* Set index/timetamp to current */
     time(&lm->ol_timestamp);

    cligen_regfd(lm->ol_fd, syslog_monitor_cb, (void *)lm );
    
    return 0;
}


static int
syslog_del_monitor(struct syslog_mon *lm)
{
    cligen_unregfd(lm->ol_fd);
    if (inotify_rm_watch(lm->ol_fd, lm->ol_wd) < 0)
	perror("inotify_rm_watch");
    close(lm->ol_fd);
    return 0;
}


static void 
cli_monitor_output_cb(char *fmt, ...)
{
    char *str;
    va_list ap;
    int len;

    va_start(ap, fmt);
    len = vsnprintf(NULL, 0, fmt, ap) + 1; /* +1 for initial \n */
    va_end(ap);
    if (len <= 0 || (str = (char *)chunk(len+1, __FUNCTION__)) == NULL) {
	fprintf(stderr, "Error: Failed to allocate memory\n");
	return;
    }
    va_start(ap, fmt);
    str[0] = '\n';
    vsnprintf(str+1, len+1, fmt, ap);
    str[len] = '\0';
    va_end(ap);

/*    gl_fixup("", -1, gl_pos);*/
    printf("%s", str);
    fflush(stdout);
//    cligen_redraw(NULL); // XXX handle

    unchunk_group(__FUNCTION__);
}

int
cli_show_logging(clicon_handle h, cvec *vars, cg_var *arg)
{
    syslog_show_local(h, cli_fmt_output_cb, 0, NULL);
    return 0;
}



int
cli_monitor(clicon_handle h, cvec *vars, cg_var *arg)
{
    static struct syslog_mon *lm = NULL;

    /* If we want to delete monitor or a monitor is already set, delete first */
    if ((!arg && lm) || lm) {
	syslog_del_monitor(lm);
	unchunk(lm);
	lm = NULL;
    }

    if (arg) {
	lm = chunk(sizeof(*lm), __FUNCTION__);
	lm->ol_outcb = cli_monitor_output_cb;
	if (syslog_set_monitor(lm) < 0) {
	    unchunk(lm);
	    lm = NULL;
	    return 0;
	}
    }
    return 0;
}
