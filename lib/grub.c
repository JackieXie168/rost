/*
 *  CVS Version: $Id: grub.c,v 1.16 2013/03/08 11:35:39 benny Exp $
 *
 *  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren
 *
 *  This file is part of ROST.
 *
 *  ROST is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  ROST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along wth ROST; see the file COPYING.  If not, see
 *  <http://www.gnu.org/licenses/>.
 *
 */
#ifdef HAVE_ROST_CONFIG_H
#include "rost_config.h" /* generated by config & autoconf */
#endif /* HAVE_ROST_CONFIG_H */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <ctype.h>
#include <netinet/in.h>
#include <blkid/blkid.h>

/* clicon */
#include <cligen/cligen.h>
#include <clicon/clicon.h>

/* lib */
#include "grub.h"

/*
 * Commands normally used in grub menu boot image sections
 */
char *grub_image_vars[] = { "title", "root", "kernel", "initrd", NULL };



void
grub_free(struct grub_conf *g)
{
  if(g->gv)
      cvec_free(g->gv);
  while(g->nent > 0)
      if(g->ent[--g->nent])
	  cvec_free(g->ent[g->nent]);

  free(g->ent);
  free(g);
}

/*
 */
struct grub_conf *
grub_parsemenu()
{
  FILE   *f = NULL;
  char   *ptr;
  char   *cmd;
  char   *args;
  char    line[512];
  cg_var *cv;
  cvec   **tmp;
  int initems = 0; /* Done with grub menu commands */
  struct grub_conf *g;
  
  errno = 0;

  if ((g = malloc(sizeof(struct grub_conf))) == NULL) {
    clicon_err(OE_UNIX, errno, "%s: malloc", __FUNCTION__);
    return NULL;
  }
  memset(g, 0, sizeof(struct grub_conf));

  if((g->gv = cvec_new(0)) == NULL) 
    goto catch;

  if ((f = fopen(GRUB_MENU, "r")) == NULL) {
    clicon_err(OE_UNIX, errno, "%s: fopen", __FUNCTION__);
    goto catch;
  }

  while((fgets(line, sizeof(line), f))) {
    if (line[0] == '#')
      continue; /* Comment */
    for(ptr=line; *ptr && isspace(*ptr); ptr++)
      /* Do nothing */ ;
    if(*ptr == '\0')
      continue; /* Empty line */
    
    /* Strip leading whitespace if any */
    for(cmd=line; isspace(*cmd); cmd++) /* Do nothing */ ;

    /* Find end of command */
    for(ptr=cmd; !isspace(*ptr); ptr++) /* Do nothing */ ;
    *ptr++='\0';
    
    if (ptr > line+sizeof(line)-1)
      args = "";
    else {
      /* Strip leading whitespace of args */
      for(args=ptr; isspace(*args); args++) /* Do nothing */  ;   
      
      /* Strip trailing whitespace of args */
      for(ptr=args+strlen(args)-1; isspace(*ptr); ptr--)
	*ptr = '\0';
    }

    if(!strcmp(cmd, "title")) {
      initems = 1;
      tmp = realloc(g->ent, (g->nent+1)*sizeof(cvec *));
      if (tmp == NULL)
	  goto catch;
      g->ent = tmp;
      if ((g->ent[g->nent] = cvec_new(0))== NULL)
	goto catch;
      if ((cv = cv_new(CGV_STRING)) == NULL)
	  goto catch;
      if(cv_parse (args, cv) < 0)
	goto catch;
      if (cv_name_set(cv, cmd) == NULL)
	  goto catch;
      if (cvec_add_cv(g->ent[g->nent], cv) == NULL)
	  goto catch;
      cv_free(cv);
      cv = NULL;
      g->nent++;
      
    } else {
	if ((cv = cv_new(CGV_STRING)) == NULL)
	    goto catch;
	if(cv_parse (args, cv) < 0)
	    goto catch;
	if (cv_name_set(cv, cmd) == NULL)
	  goto catch;
	if (initems) /* Add to current item */
	    cvec_add_cv(g->ent[g->nent-1], cv);
	else
	    cvec_add_cv(g->gv, cv);
	cv_free(cv); 
	cv = NULL;
    }
  }
  fclose(f);

  return g;

 catch:
  if (errno)
    clicon_err(OE_UNIX, errno, "%s", __FUNCTION__);
  if (f)
    fclose(f);
  if (g)
    grub_free(g);
  if (cv)
      cv_free(cv);

  return NULL;
}

/* 
 * Get UUID of filesystem 
*/
char *
grub_getuuid(char *path, const char *label)
{
    int i;
    int ndp;
    int maj, min;
    const char *uuid;
    struct dirent *dp;
    blkid_probe pr = NULL;
    struct stat st;
    char *ret;
    char *file = NULL;

    /* Get device id for file */
    if (stat(path, &st)) {
	clicon_err(OE_UNIX, errno, "%s: stat: %s",
		   __FUNCTION__, strerror(errno));
	goto catch;
    }
    maj = major(st.st_dev);
    min = minor(st.st_dev);
    
    /* List block devices in /dev */
    if((ndp = clicon_file_dirent("/dev", &dp, NULL, S_IFBLK, __FUNCTION__))<0){
	clicon_err(OE_UNIX, errno, "%s: dirent: %s",
		   __FUNCTION__, strerror(errno));
	goto catch;
    }
    
    /* Locate device file with matching id */
    for (i = 0; i < ndp; i++) {
	file = chunk_sprintf(__FUNCTION__, "/dev/%s", dp[i].d_name);
	if (stat(file, &st)) {
	    clicon_err(OE_UNIX, errno, "%s: stat: %s",
		       __FUNCTION__, strerror(errno));
	    goto catch;
	}
	if (major(st.st_rdev) == maj && minor(st.st_rdev) == min)
	    break;

	unchunk(file);
	file = NULL;
    }

    if(file == NULL) {
	clicon_err(OE_CFG, 0, "%s: Unable to locate device", __FUNCTION__);
	goto catch;
    }
	    
    if ((pr = blkid_new_probe_from_filename(file)) == NULL) {
	clicon_err(OE_UNIX, errno, "%s: Unable to open %s", __FUNCTION__, file);
	goto catch;
    }
    blkid_do_probe(pr);
    blkid_probe_lookup_value(pr, "UUID", &uuid, NULL);

    if (strlen(uuid) <= 0) {
	clicon_err(OE_UNIX, 0, "%s: %s has no  UUID", __FUNCTION__, file);
	goto catch;
    }
    
    ret = chunk_sprintf(label, "%s", uuid);
    blkid_free_probe(pr);
    unchunk_group(__FUNCTION__);
    return ret;

 catch: 
    if(pr)
	blkid_free_probe(pr);
    unchunk_group(__FUNCTION__);
    return NULL;
}


/*
 * Print menu to FILE pointer. Return the number of bytes written.
 * XXX Should take care of fprintf errors.
 */ 
int
grub_printmenu(struct grub_conf *g, FILE *f)
{
  int ret = 0;
  cg_var *cv;
  cvec *vr;
  int idx, ent;

  ret += fprintf(f, "# Automatically generated by RNR CLI\n");
  cv = NULL;
  vr = g->gv;
  while ((cv = cvec_each(vr, cv))) {
      ret += fprintf(f, "%s\t%s\n", cv_name_get(cv), cv_string_get(cv));
  }  

  ret += fprintf(f, "\n");
  for (ent = 0; ent < g->nent; ent++) {
    if ((vr = g->ent[ent]) == NULL)
      continue;
    ret += fprintf(f, "\n");
    for(idx = 0; grub_image_vars[idx]; idx++) {
      if((cv = cvec_find(vr, grub_image_vars[idx]))) {
	ret += fprintf(f, "%s\t%s\n", cv_name_get(cv), cv_string_get(cv));
	cvec_del(vr, cv);
      }
    }
    cv = NULL;
    while ((cv = cvec_each(vr, cv))) {
      ret += fprintf(f, "%s\t%s\n",cv_name_get(cv), cv_string_get(cv));
    }
  }
  
  return ret;
}

/*
 * Add image to grub menuconf after verification.
 * If grubconf struct is NULL, it will be generated by parsing the current 
 * menu file. Returns update config on success and NULL on failure.
 * XXX Should perhaps be extended to allow the user to define a file: or 
 * XXX tftp location (grub network boot)?
 */
struct grub_conf *
grub_addimage(struct grub_conf *g, char *img)
{
  int     i;
  char   *file;
  char   *uuid;
  cg_var *cv = NULL;
  cg_var *v;
  char   *cmd;
  FILE   *p = NULL;
  struct stat st;
  cvec *vr;
  struct grub_conf *new = NULL;


  if (strchr(img, '/')) {
    clicon_err(OE_CFG, 0, "%s: invalid file name", __FUNCTION__, img);
    goto catch;
  }    
  
  file = chunk_sprintf(__FUNCTION__, "%s/%s", ROST_IMAGE_DIR, img);
  if (file == NULL) {
    clicon_err(OE_UNIX, errno, "%s: chunk", __FUNCTION__);
    goto catch;
  }

  if (stat(file, &st) < 0){
    clicon_err(OE_UNIX, errno, "%s: %s",  __FUNCTION__, file);
    goto catch;
  }

  /* Image a regular file? */
  if (!S_ISREG(st.st_mode)){
    clicon_err(OE_UNIX, 0, "%s is not a regular file", __FUNCTION__, img);
    goto catch;
  }    
  /* Verify that file is a bootable kernel. XXX A better method then popen? */
  cmd = chunk_sprintf(__FUNCTION__,
	      "file %s | grep -q 'Linux kernel x86 boot executable bzImage'",
		      file);
  if (cmd) {
    if ((p = popen(cmd, "r"))) {
      if(pclose(p) != 0)  {
	clicon_err(OE_UNIX, 0, "%s: %s is not a valid system image\n",
		__FUNCTION__, img);
	goto catch;
      }
    } else {
      clicon_err(OE_UNIX, errno, "%s: Image verification failed\n", __FUNCTION__);
    }
  }
    
  /* File system UUID for */
  if ((uuid = grub_getuuid(file, __FUNCTION__)) == NULL)
    goto catch;

  if (g == NULL) { /* Parse menu file */
    if ((new = grub_parsemenu()) == NULL) {
      clicon_err(OE_UNIX, 0, "%s: Failed to parse boot loader menu\n", __FUNCTION__);
      return 0;
    }
    g = new;
  }

  /* Check for duplicate */
  for (i=0; i < g->nent; i++) {
    vr = g->ent[i];
    if((v = cvec_find(vr, "title")) && !strcmp(cv_string_get(v), img))
      break;
  }
  
  if (i < g->nent) { /* Duplicate. Silently ignore ?? */
    clicon_err(OE_CFG, 0, "Duplicate entry\n");
    goto catch;
  }
  
  if ((g->ent = realloc(g->ent, (g->nent+1) * sizeof(cvec *))) == NULL)
    goto catch;
  if ((g->ent[g->nent] = cvec_new(0))== NULL)
    goto catch;
  vr = g->ent[g->nent++];
    
  if ((cv = cv_new(CGV_STRING)) == NULL){
      clicon_err(OE_CFG, errno, "cv_new");
      goto catch;
  }

  /* Add commands */
  if (cv_name_set(cv, "title") == NULL || cv_string_set(cv, img) == NULL)
      goto catch;
  cvec_add_cv(vr, cv);

  cv_reset(cv);

  if (cv_name_set(cv, "root") == NULL || 
      cv_string_set(cv, "(hd0,0)") == NULL) /* XXX May not be true on all systems */
      goto catch;
  cvec_add_cv(vr, cv);
  cv_reset(cv);

  if (cv_name_set (cv, "kernel") == NULL ||
      cv_string_set(cv, chunk_sprintf(__FUNCTION__, 
					      "%s console=tty0 console=ttyS0,9600 quiet rostflash=%s",
					      file+strlen(ROST_FLASH_DIR), uuid)) == NULL)
      goto catch;
  cvec_add_cv(vr, cv);

  cv_free(cv);
  cv = NULL;
  
  unchunk_group(__FUNCTION__);
  return g;
  
 catch:
  if (cv)
      cv_free(cv);
  if (g)
    grub_free(g);
  unchunk_group(__FUNCTION__);
  return NULL;
}


/*
 * Delete image from grub's menu.lst
 */
struct grub_conf *
grub_delimage(struct grub_conf *g, char *img)
{
  int i;
  cg_var *cv;
  struct grub_conf *new = NULL; 

  if (g == NULL) {
    if ((new = grub_parsemenu()) == NULL) {
      clicon_err(OE_UNIX, 0, "%s: Failed to parse boot loader menu\n", __FUNCTION__);
      goto catch;
    }
    g = new;
  }
  
  for (i=0; i < g->nent; i++)
    if((cv = cvec_find(g->ent[i], "title")) && !strcmp(cv_string_get(cv), img))
      break;
  if (i >= g->nent) { /* Not found */
    clicon_err(OE_CFG, 0, "Entry does not exist\n");
    goto catch;
  }
  
  cvec_free(g->ent[i]);
  if (g->nent-1 > i)
    memcpy(&g->ent[i], &g->ent[i+1], ((g->nent-1)-i)*sizeof(cvec *));
  g->ent[g->nent-1] = NULL;
  g->nent--;

  unchunk_group(__FUNCTION__);
  return g;
  
 catch:
  if (new)
    grub_free(new);
  unchunk_group(__FUNCTION__);
  return NULL;
}

