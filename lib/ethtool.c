/*
 *  CVS Version: $Id: ethtool.c,v 1.4 2011/08/21 19:43:38 olof Exp $
 *
 *  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren
 *
 *  This file is part of ROST.
 *
 *  ROST is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  ROST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along wth ROST; see the file COPYING.  If not, see
 *  <http://www.gnu.org/licenses/>.
 *
 */
#ifdef HAVE_OSR_CONFIG_H
#include "osr_config.h" /* generated by config & autoconf */
#endif /* HAVE_OSR_CONFIG_H */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <assert.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <netinet/in.h>

#include <linux/sockios.h>
#include <linux/ethtool.h> 
#include <linux/ethtool.h>
#include <linux/sockios.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clicon/clicon.h>

#include "ethtool.h"

static int
osr_ethtool_socket()
{
  int fd;

  fd = socket(AF_INET, SOCK_DGRAM, 0);
  if (fd < 0) {
      clicon_err(OE_UNIX, errno, "socket(ETHTOOL)");
    return -1;
  }
  return fd;
}

int
osr_ethtool_gset(char *ifname, struct ethtool_cmd *ep)
{
  int fd;
  int ret = -1;
  struct ifreq ifr;
  
  memset(&ifr, 0, sizeof(ifr));
  strncpy(ifr.ifr_name, ifname, IF_NAMESIZE-1);
  
  if ((fd = osr_ethtool_socket()) == -1)
    return -1;

  ep->cmd = ETHTOOL_GSET;
  ifr.ifr_data = (caddr_t)ep;

  if ((ioctl(fd, SIOCETHTOOL, &ifr) < 0)) {
    if (errno != EOPNOTSUPP)
      clicon_err(OE_UNIX, errno, "ioctl(SIOCETHTOOL)");
    goto catch;
  }
  ret = 0;

 catch:
  close(fd);
  return ret;
}

/*
 *
 */
struct osr_etstats *
osr_ethtool_gstats(char *ifname, const char *label)
{
    int i;
    int fd;
    int nstats;
    struct ifreq ifr;
    struct ethtool_drvinfo drvinfo;
    struct ethtool_stats *stats;
    struct ethtool_gstrings *strings;
    struct osr_etstats *etsp;

    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, ifname, IFNAMSIZ-1);
  
    if ((fd = osr_ethtool_socket()) == -1)
	return NULL;
  
    drvinfo.cmd = ETHTOOL_GDRVINFO;
    ifr.ifr_data = (caddr_t)&drvinfo;
    if ((ioctl(fd, SIOCETHTOOL, &ifr) < 0)) {
	if (errno != EOPNOTSUPP)
	    clicon_err(OE_UNIX, errno, "%s", strerror(errno));
	goto catch;
    }
  
    if ((nstats = drvinfo.n_stats) < 1)
	goto catch;
  
    strings = chunk(sizeof(struct ethtool_gstrings) + 
		    nstats * ETH_GSTRING_LEN, __FUNCTION__);
    if (strings == NULL) {
	clicon_err(OE_UNIX, errno, "failed to allocate memory");
	goto catch;
    }
  
    strings->cmd = ETHTOOL_GSTRINGS;
    strings->string_set = ETH_SS_STATS;
    strings->len = nstats;
    ifr.ifr_data = (caddr_t)strings;
    if ((ioctl(fd, SIOCETHTOOL, &ifr)) < 0) {
	clicon_err(OE_UNIX, errno, "failed to retrieve strings");
	goto catch;
    }
  
    stats = chunk(sizeof(struct ethtool_stats) + 
		  nstats * sizeof(uint64_t),
		  __FUNCTION__);
    stats->cmd = ETHTOOL_GSTATS;
    stats->n_stats = nstats;
    ifr.ifr_data = (caddr_t)stats;
    if ((ioctl(fd, SIOCETHTOOL, &ifr)) < 0) {
	clicon_err(OE_UNIX, errno, "failed to retrieve stats");
	goto catch;
    }
    
    etsp = (struct osr_etstats *)
	chunk(sizeof(struct osr_etstats) +
	      (nstats * sizeof(struct osr_etstatent)),
	      label);
    if (etsp == NULL) {
	clicon_err(OE_UNIX, errno, "failed to allocate memory");
	goto catch;
    }
  
    etsp->ets_nstats = nstats;
    for (i = 0; i < nstats; i++) {
	strncpy(etsp->ets_stat[i].etse_name, 
		(const char *)&strings->data[i * ETH_GSTRING_LEN],
		ETH_GSTRING_LEN);
	etsp->ets_stat[i].etse_value = stats->data[i];
    }
  
    close (fd);
    unchunk_group(__FUNCTION__);
    return etsp;
  
catch:
    close (fd);
    unchunk_group(label);
    unchunk_group(__FUNCTION__);
    return NULL;
}

int
osr_ethtool_stat(struct osr_etstats *ets, char *name)
{
  int i;

  for (i = 0; i < ets->ets_nstats; i++)
    if (!strcmp(ets->ets_stat[i].etse_name, name))
      return i;
  return -1;
}  

int
osr_ethtool_getlink(const char *ifname, int *link)
{
    int fd;
    int retval = -1;
    struct ifreq ifr;
    struct ethtool_value edata;
    
    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, ifname, IF_NAMESIZE-1);
    
    if ((fd = osr_ethtool_socket()) == -1)
	return -1;

    edata.cmd = ETHTOOL_GLINK;
    ifr.ifr_data = (caddr_t)&edata;
    if ((ioctl(fd, SIOCETHTOOL, &ifr)) < 0) {
	if (errno != EOPNOTSUPP)
	    clicon_err(OE_UNIX, errno, "failed to retrieve stats");
	goto catch;
    }
    
    *link = edata.data ? 1 : 0;
    retval = 0;

catch:
    close (fd);
    return retval;
}

int
osr_ethtool_drvinfo(const char *ifname, struct ethtool_drvinfo *drvinfo)
{
    int fd;
    int retval = -1;
    struct ifreq ifr;

    if ((fd = osr_ethtool_socket()) == -1)
	return -1;

    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, ifname, IF_NAMESIZE-1);
    
    drvinfo->cmd = ETHTOOL_GDRVINFO;
    ifr.ifr_data = (caddr_t)drvinfo;
    if ((ioctl(fd, SIOCETHTOOL, &ifr)) < 0) {
	if (errno != EOPNOTSUPP)
	    clicon_err(OE_UNIX, errno, "failed to retrieve driver info for %s", ifname);
	goto catch;
    }

    retval = 0;
catch:
    close (fd);
    return retval;
}

/*
 * osr_ifspeed
 * 'Forced' speed according to ethtool in bps
 */
int
osr_ifspeed(char *ifname, uint32_t *speed)
{
    struct ethtool_cmd ec;
    struct ifreq ifr;
    int fd;
    int retval = -1;

    /* Setup our control structures. */
    memset(&ifr, 0, sizeof(ifr));
    strcpy(ifr.ifr_name, ifname);

    /* Open control socket. */
    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0){
	clicon_err(OE_UNIX, errno, "socket");
	goto err;
    }
    ec.cmd = ETHTOOL_GSET;
    ifr.ifr_data = (caddr_t)&ec;
    if (ioctl(fd, SIOCETHTOOL, &ifr) < 0){
	clicon_err(OE_UNIX, errno, "ioctl SIOCGETHTOOL");
	goto err;
    }
    close(fd);
    *speed = ethtool_cmd_speed(&ec);
    retval = 0;
  err:
    return retval;
}
